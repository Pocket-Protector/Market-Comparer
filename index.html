<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Market Comparer</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js"></script>
<!-- config -->
<script src="config.js"></script>
<style>
  :root { --bg:#0b1020; --panel:#0e1729; --border:#1f2937; --text:#e5e7eb; --muted:#94a3b8; }
  body { margin:0; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
  .container { max-width: 1280px; margin: 24px auto; padding: 0 16px; }
  h1 { font-size: 20px; margin: 0 0 10px 0; font-weight:700; }
  .last-updated { color: var(--muted); font-size: 12px; margin: 2px 0 16px; }

  /* chips/buttons */
  .chips { display:flex; gap:8px; flex-wrap:wrap; margin: 0 0 10px; }
  .chip { padding:6px 10px; border-radius:999px; border:1px solid var(--border); cursor:pointer; user-select:none; font-size:12px; background:#121a30; }
  .chip.on { box-shadow: inset 0 0 0 999px #ffffff10; }
  .chip.drift { background:#8d23ff22; } .chip.dydx { background:#2382ff22; } .chip.hyper { background:#25ff7122; }
  .chip.refresh { background:#0b1325; }
  
  /* Update progress bar */
  .update-progress { display: flex; align-items: center; gap: 12px; margin: 8px 0 16px; }
  .progress-bar { flex: 1; height: 6px; background: #1f2937; border-radius: 3px; overflow: hidden; }
  .progress-fill { height: 100%; background: linear-gradient(90deg, #25ff71, #2382ff); border-radius: 3px; transition: width 1s ease; }
  .progress-text { font-size: 12px; color: var(--muted); min-width: 80px; }
  
  /* GitHub link */
  .github-link { display: inline-flex; align-items: center; margin-left: 12px; color: var(--muted); text-decoration: none; transition: color 0.2s ease; }
  .github-link:hover { color: var(--text); }
  .github-link svg { width: 20px; height: 20px; }

  .toolbar { display:flex; flex-wrap:wrap; gap:12px; align-items:center; background:var(--panel); border:1px solid var(--border); padding:12px; border-radius:12px; }
  .toolbar label { font-size:12px; color: var(--muted); }
  .toolbar input[type="text"], .toolbar select, .toolbar input[type="number"] { padding:8px 10px; border-radius:10px; border:1px solid var(--border); background:#0b1325; color:var(--text); min-width: 90px; }

  .table-wrap { margin-top:16px; background:var(--panel); border:1px solid var(--border); border-radius:12px; overflow:hidden; }
  table { width:100%; border-collapse:separate; border-spacing:0; }
  thead th { position: sticky; top: 0; background:#0b1325; color:#cbd5e1; font-weight:600; font-size:12px;
             text-align:left; padding:10px; border-bottom:1px solid var(--border); user-select:none; }
  thead th.sortable { cursor:pointer; }
  thead th.sortable .arrow { opacity:0.5; margin-left:6px; font-size:11px; }
  thead th.sortable.active .arrow { opacity:1; }
  tbody td { padding:10px; font-size:13px; border-bottom:1px solid #111827; vertical-align: top; }
  .group-row td { background:#0b1020; color:#93c5fd; font-weight:700; font-size:12px; text-transform: uppercase;
                  letter-spacing:0.06em; border-top:1px solid var(--border); cursor:pointer; }
  .group-row .sub { font-weight:400; color:#9ca3af; text-transform:none; letter-spacing:0; font-size: 11px; margin-left: 8px; }

  .ex-drift td { background:#8d23ff22; } .ex-drift:hover td { background:#f3e8ff33; }
  .ex-dydx td { background:#2382ff22; } .ex-dydx:hover td { background:#dbeafe33; }
  .ex-hyperliquid td { background:#25ff7122; } .ex-hyperliquid:hover td { background:#bbf7d033; }

  .badge { font-size:11px; padding:2px 6px; border-radius:6px; border:1px solid #233047; color:#a5b4fc; background:#0b1325; }
  .empty { color:#64748b; font-style:italic; }
  .footer { margin-top:10px; font-size:12px; color:#94a3b8; }

  .drawer { background:#0b1325; border-top:1px dashed #1f2a44; padding:12px 10px 14px 10px; }
  .charts { display:grid; gap:14px; grid-template-columns: 1fr; }
  @media (min-width: 980px) { .charts { grid-template-columns: 1fr 1fr; } }
  .chart-card { border:1px solid var(--border); border-radius:10px; padding:8px; background:#0d162c; }
  .chart-head { display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; font-size:12px; color:var(--muted); }
  .toggles { display:flex; gap:8px; flex-wrap:wrap; }
  .tog { display:flex; align-items:center; gap:6px; font-size:12px; }
  .note { font-size:12px; color:#9ca3af; margin-top:6px; }
  .changes { margin-top:10px; font-size:12px; color:#cbd5e1; }
  .changes h4 { margin: 6px 0; font-size:12px; color:#9ca3af; }
  .changes li { margin: 2px 0; }
</style>
</head>
<body>
  <div class="container">
    <h1 id="title">
      Market Comparer
      <a href="https://github.com/Pocket-Protector/Market-Comparer" target="_blank" class="github-link" title="View on GitHub">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
        </svg>
      </a>
    </h1>
    <div class="last-updated" id="lastUpdated">Loading last updated…</div>
    <div class="update-progress" id="updateProgress" style="display: none;">
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <span class="progress-text" id="progressText">Updates in 59m</span>
    </div>

    <!-- exchange chips -->
    <div class="chips" id="exchangeChips">
      <span class="chip drift on" data-ex="drift">drift</span>
      <span class="chip dydx on" data-ex="dydx">dydx</span>
      <span class="chip hyper on" data-ex="hyperliquid">hyperliquid</span>
    </div>

    <!-- toolbar -->
    <div class="toolbar">
      <label>Symbol: <input id="symFilter" type="text" placeholder="e.g. BTC-USD" /></label>
      <label>Type:
        <select id="typeFilter">
          <option value="">All</option>
          <option value="CROSS">CROSS</option>
          <option value="ISOLATED">ISOLATED</option>
        </select>
      </label>
      <label>Presence:
        <select id="presenceFilter">
          <option value="">All</option>
          <option value="not_dydx">Not on dYdX</option>
          <option value="not_drift">Not on Drift</option>
          <option value="not_hyperliquid">Not on Hyperliquid</option>
        </select>
      </label>
      <label>Baseline:
        <select id="baselineSel">
          <option value="dydx">dydx</option>
          <option value="drift">drift</option>
          <option value="hyperliquid">hyperliquid</option>
        </select>
      </label>
    </div>

    <!-- table -->
    <div class="table-wrap">
      <table id="grid">
        <thead>
          <tr>
            <th style="width:10%">Exchange</th>
            <th style="width:10%">Type</th>
            <th style="width:18%">Symbol</th>
            <th class="sortable" data-key="leverage_max" style="width:10%">Lev <span class="arrow">↕</span></th>
            <th style="width:12%">Price</th>
            <th class="sortable" data-key="volume_24h_usd" style="width:12%">24h Vol <span class="arrow">↕</span></th>
            <th class="sortable" data-key="open_interest_usd" style="width:12%">OI <span class="arrow">↕</span></th>
            <th class="sortable" data-key="vol_oi_ratio" style="width:8%">Vol/OI <span class="arrow">↕</span></th>
            <th class="sortable" data-key="vol_vs_base_x" style="width:8%">Vol vs Base <span class="arrow">↕</span></th>
            <th class="sortable" data-key="oi_vs_base_x" style="width:8%">OI vs Base <span class="arrow">↕</span></th>
          </tr>
        </thead>
        <tbody id="body">
          <tr><td colspan="10" class="empty">Loading data from API…</td></tr>
        </tbody>
      </table>
    </div>
    <div class="footer" id="summary"></div>
  </div>

<script>
/* ============================================================
   API CONFIG — Perps API integration
   ============================================================ */
const API_BASE = "https://perps-node-d942af6814fa.herokuapp.com";
const API_KEY = '{{API_KEY}}';

// Check if we have API key
if (!API_KEY || API_KEY === '{{API_KEY}}') {
  console.warn('API_KEY not found. Please set the API_KEY GitHub secret.');
}

/* ===========================
   STATE & CONSTANTS
   =========================== */
const tbody   = document.getElementById('body');
const summary = document.getElementById('summary');
const symFilterEl  = document.getElementById('symFilter');
const typeFilterEl = document.getElementById('typeFilter');
const presenceEl   = document.getElementById('presenceFilter');
const baselineSel  = document.getElementById('baselineSel');
const chipsWrap    = document.getElementById('exchangeChips');
const lastUpdatedEl = document.getElementById('lastUpdated');
const titleEl = document.getElementById('title');
const headerCells  = Array.from(document.querySelectorAll('thead th.sortable'));
const refreshBtn = document.getElementById('refreshBtn');

const COLORS = { drift:'#8d23ff', dydx:'#2382ff', hyperliquid:'#25ff71' };

let rowsRaw = [];
let rowsFiltered = [];
let historicalData = [];     // All historical data for charts
let symbolAliases = new Map(); // symbol_raw -> symbol_canonical
let exchangeOn = { drift:true, dydx:true, hyperliquid:true };
let sortKey = null;
let sortDir = 'desc';
let drawers = new Map();     // symbol_raw -> {host, charts}
let historyCache = new Map();// symbol_raw -> history payload
let lastLoadTs = 0;
let isLoading = false;

/* ===========================
   API CLIENT
   =========================== */
class PerpsAPIClient {
  constructor(baseUrl, apiKey) {
    this.baseUrl = baseUrl;
    this.apiKey = apiKey;
    this.cache = new Map();
    this.cacheTTL = 600000; // 10 minutes
  }

  async _get(endpoint, params = {}) {
    const url = new URL(`${this.baseUrl}${endpoint}`);
    Object.keys(params).forEach(key => url.searchParams.append(key, params[key]));
    
    const cacheKey = `${endpoint}:${JSON.stringify(params)}`;
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
      return cached.data;
    }

    const response = await fetch(url, {
      headers: {
        'x-api-key': this.apiKey
      }
    });

    if (!response.ok) {
      if (response.status === 401) throw new Error('Invalid API key');
      if (response.status === 429) throw new Error('Rate limit exceeded');
      throw new Error(`API error: ${response.status}`);
    }

    const data = await response.json();
    this.cache.set(cacheKey, { data, timestamp: Date.now() });
    return data;
  }

  async getLatestData(limit = 1000) {
    return await this._get('/v1/marketcompare/latest_data', { limit });
  }

  async getAllDailyData(limit = 10000) {
    // Try single request first
    const response = await this._get('/v1/marketcompare/daily_data', { all: 1, limit });
    
    // If we got less data than requested, we have everything
    if (response.data && response.data.length < limit) {
      return response;
    }
    
    // If we got exactly the limit, we might need pagination
    // Check if there's more data by requesting one more record
    const nextResponse = await this._get('/v1/marketcompare/daily_data', { 
      all: 1, 
      limit: 1, 
      offset: limit 
    });
    
    // If there's more data, use pagination
    if (nextResponse.data && nextResponse.data.length > 0) {
      console.log('Large dataset detected, using pagination...');
      return await this._getAllDailyDataPaginated(limit);
    }
    
    return response;
  }

  async _getAllDailyDataPaginated(limit) {
    const allData = [];
    let offset = 0;
    const batchSize = 1000; // API max per request
    
    while (allData.length < limit) {
      const remaining = limit - allData.length;
      const currentBatchSize = Math.min(batchSize, remaining);
      
      const response = await this._get('/v1/marketcompare/daily_data', { 
        all: 1, 
        limit: currentBatchSize, 
        offset: offset 
      });
      
      const batchData = response.data || [];
      if (batchData.length === 0) break; // No more data
      
      allData.push(...batchData);
      offset += currentBatchSize;
      
      // Update progress for large datasets
      if (window.updateProgress && allData.length % 5000 === 0) {
        window.updateProgress(`Loading historical data... ${allData.length} records`);
      }
      
      // If we got less than requested, we're done
      if (batchData.length < currentBatchSize) break;
    }
    
    return {
      cached: false,
      data: allData,
      pagination: { limit: allData.length, offset: 0 },
      meta: { total_fetched: allData.length, paginated: true }
    };
  }

  async getSymbolAliases(limit = 1000) {
    return await this._get('/v1/marketcompare/symbol_aliases', { limit });
  }

  async getSymbolRegistry(limit = 1000) {
    return await this._get('/v1/marketcompare/symbol_registry', { limit });
  }
}

const apiClient = new PerpsAPIClient(API_BASE, API_KEY);

/* ===========================
   SYMBOL RESOLUTION
   =========================== */
function resolveSymbol(symbol) {
  return symbolAliases.get(symbol) || symbol;
}

function normalizeSymbol(symbol) {
  if (!symbol) return symbol;
  let s = symbol.trim().toUpperCase();
  if (!s.includes('-') && s) {
    s = `${s}-USD`;
  }
  return resolveSymbol(s);
}

/* ===========================
   PROGRESS INDICATORS
   =========================== */
function showProgressBar(message = 'Loading...') {
  const progressEl = document.getElementById('progressBar') || createProgressBar();
  progressEl.textContent = message;
  progressEl.style.display = 'block';
}

// Global progress update function
window.updateProgress = function(message) {
  const progressEl = document.getElementById('progressBar');
  if (progressEl) {
    progressEl.textContent = message;
  }
};

function hideProgressBar() {
  const progressEl = document.getElementById('progressBar');
  if (progressEl) {
    progressEl.style.display = 'none';
  }
}

function createProgressBar() {
  const progressEl = document.createElement('div');
  progressEl.id = 'progressBar';
  progressEl.style.cssText = `
    position: fixed; top: 0; left: 0; right: 0; z-index: 1000;
    background: #1f2937; color: #e5e7eb; padding: 8px 16px;
    text-align: center; font-size: 14px; border-bottom: 1px solid #374151;
  `;
  document.body.appendChild(progressEl);
  return progressEl;
}

function showError(message) {
  const errorEl = document.getElementById('errorBar') || createErrorBar();
  errorEl.textContent = `Error: ${message}`;
  errorEl.style.display = 'block';
  setTimeout(() => errorEl.style.display = 'none', 5000);
}

function createErrorBar() {
  const errorEl = document.createElement('div');
  errorEl.id = 'errorBar';
  errorEl.style.cssText = `
    position: fixed; top: 0; left: 0; right: 0; z-index: 1001;
    background: #dc2626; color: white; padding: 8px 16px;
    text-align: center; font-size: 14px; font-weight: 500;
  `;
  document.body.appendChild(errorEl);
  return errorEl;
}

/* ===========================
   FORMATTERS
   =========================== */
const num = (v) => { if (v === null || v === undefined || v === '') return null; const n = Number(v); return Number.isFinite(n) ? n : null; };

function usdShort(n) {
  const x = num(n); if (x === null) return '';
  const sign = x < 0 ? '-' : '';
  const v = Math.abs(x);
  if (v >= 1e9)  return `${sign}$${(v/1e9).toFixed(2)}B`;
  if (v >= 1e6)  return `${sign}$${(v/1e6).toFixed(2)}M`;
  if (v >= 1e3)  return `${sign}$${(v/1e3).toFixed(2)}K`;
  return `${sign}$${v.toFixed(2)}`;
}
function priceUsd(p) {
  const x = num(p); if (x === null) return '';
  if (x < 1) return `$${x.toFixed(6)}`;
  if (x < 100) return `$${x.toFixed(3)}`;
  if (x < 10000) return `$${x.toFixed(2)}`;
  return `$${x.toFixed(0)}`;
}
function ratioVolOI(row) {
  const v = num(row.volume_24h_usd), oi = num(row.open_interest_usd);
  if (v === null || oi === null || oi === 0) return null;
  return v / oi;
}
function fmtRatio(val) {
  if (val === null) return '—';
  if (!isFinite(val)) return '—';
  return val.toFixed(2);
}
function fmtX(val, isSelected=false) {
  if (isSelected) return 'selected';
  if (val === null || !isFinite(val) || val <= 0) return '—';
  return `${val.toFixed(2)}×`;
}
function exClass(ex) {
  const s = String(ex||'').toLowerCase();
  if (s.includes('drift')) return 'ex-drift';
  if (s.includes('dydx')) return 'ex-dydx';
  if (s.includes('hyper')) return 'ex-hyperliquid';
  return '';
}

/* ===========================
   NORMALIZATION
   =========================== */
function ensureColumns(row) {
  const m = {}; for (const k in row) m[k.toLowerCase()] = row[k];
  const r = {
    exchange: (m['exchange'] ?? '').toLowerCase(),
    market_type: (m['market_type'] ?? '').toUpperCase(),
    symbol_raw: (m['symbol_raw'] ?? '').toUpperCase(),
    leverage_max: m['leverage_max'] ?? '',
    price_usd: m['price_usd'] ?? '',
    volume_24h_usd: m['volume_24h_usd'] ?? '',
    open_interest_usd: m['open_interest_usd'] ?? '',
    daily_snapshot: m['daily_snapshot'] ?? '',
  };
  r.leverage_max_num = num(r.leverage_max);
  r.volume_num = num(r.volume_24h_usd);
  r.oi_num = num(r.open_interest_usd);
  r.vol_oi_ratio = ratioVolOI(r);
  return r;
}

/* ===========================
   GROUP HELPERS
   =========================== */
function groupBySymbol(rows) {
  const g = {};
  for (const r of rows) (g[r.symbol_raw] ??= []).push(r);
  return g;
}
function presentSet(group) {
  const s = new Set(); for (const r of group) s.add(r.exchange); return s;
}
function presencePass(s, preset) {
  if (!preset) return true;
  if (preset === 'not_dydx') return !s.has('dydx');
  if (preset === 'not_drift') return !s.has('drift');
  if (preset === 'not_hyperliquid') return !s.has('hyperliquid');
  return true;
}
function groupMaxValue(group, key) {
  let top = null;
  for (const r of group) {
    let v = null;
    if (key === 'leverage_max') v = r.leverage_max_num;
    else if (key === 'volume_24h_usd') v = r.volume_num;
    else if (key === 'open_interest_usd') v = r.oi_num;
    else if (key === 'vol_oi_ratio') v = r.vol_oi_ratio;
    else if (key === 'vol_vs_base_x') v = r.vol_vs_base_x ?? null;
    else if (key === 'oi_vs_base_x') v = r.oi_vs_base_x ?? null;
    if (v !== null) top = (top === null ? v : Math.max(top, v));
  }
  return top;
}

/* ===========================
   BASELINE COMPARISON
   =========================== */
function injectBaselineComparisons(groups, baseline) {
  for (const sym in groups) {
    const g = groups[sym];
    const base = g.find(r => r.exchange === baseline);
    const baseVol = base ? num(base.volume_24h_usd) : null;
    const baseOI  = base ? num(base.open_interest_usd) : null;
    for (const r of g) {
      if (base && r.exchange === baseline) {
        r.vol_vs_base_x = null;
        r.oi_vs_base_x  = null;
      } else {
        const v = num(r.volume_24h_usd), o = num(r.open_interest_usd);
        r.vol_vs_base_x = (v !== null && baseVol && baseVol > 0) ? v / baseVol : null;
        r.oi_vs_base_x  = (o !== null && baseOI && baseOI > 0) ? o / baseOI : null;
      }
    }
  }
}

/* ===========================
   CHART DISPOSAL (fixes “glitch on chips click”)
   =========================== */
function disposeAllDrawers() {
  drawers.forEach(({host, charts}) => {
    try { charts?.vol?.destroy?.(); } catch(_) {}
    try { charts?.oi?.destroy?.(); } catch(_) {}
  });
  drawers.clear();
}

/* ===========================
   RENDER TABLE
   =========================== */
function groupValueKey(r, key) {
  if (key === 'leverage_max') return r.leverage_max_num;
  if (key === 'volume_24h_usd') return r.volume_num;
  if (key === 'open_interest_usd') return r.oi_num;
  if (key === 'vol_oi_ratio') return r.vol_oi_ratio;
  if (key === 'vol_vs_base_x') return r.vol_vs_base_x ?? null;
  if (key === 'oi_vs_base_x') return r.oi_vs_base_x ?? null;
  return null;
}

function renderTable(data) {
  // dispose existing charts & drawer refs BEFORE nuking DOM
  disposeAllDrawers();

  if (!data || data.length === 0) {
    tbody.innerHTML = `<tr><td colspan="10" class="empty">No rows match the current filters.</td></tr>`;
    summary.textContent = '';
    return;
  }

  let groups = groupBySymbol(data);
  injectBaselineComparisons(groups, baselineSel.value);

  const preset = presenceEl.value;
  let symbols = Object.keys(groups).filter(sym => presencePass(presentSet(groups[sym]), preset));

  if (sortKey) {
    const dir = (sortDir === 'asc') ? 1 : -1;
    symbols.sort((a, b) => {
      const av = groupMaxValue(groups[a], sortKey);
      const bv = groupMaxValue(groups[b], sortKey);
      if (av === null && bv === null) return a.localeCompare(b);
      if (av === null) return 1;
      if (bv === null) return -1;
      return (av < bv ? -1 : av > bv ? 1 : 0) * dir;
    });
  } else {
    symbols.sort((a,b) => a.localeCompare(b));
  }

  let html = ''; let total = 0;
  for (const sym of symbols) {
    let group = groups[sym].filter(r => exchangeOn[r.exchange]);
    if (group.length === 0) continue;

    if (sortKey) {
      const dir = (sortDir === 'asc') ? 1 : -1;
      group = group.slice().sort((a,b) => {
        const av = groupValueKey(a, sortKey), bv = groupValueKey(b, sortKey);
        if (av === null && bv === null) return String(a.exchange).localeCompare(String(b.exchange));
        if (av === null) return 1;
        if (bv === null) return -1;
        return (av < bv ? -1 : av > bv ? 1 : 0) * dir;
      });
    } else {
      group = group.slice().sort((a,b) => String(a.exchange).localeCompare(String(b.exchange)));
    }

    html += `<tr class="group-row" data-sym="${sym}"><td colspan="10">${sym}<span class="sub">(click to view charts)</span></td></tr>`;
    for (const r of group) {
      html += `
        <tr class="${exClass(r.exchange)}">
          <td>${r.exchange}</td>
          <td><span class="badge">${r.market_type || ''}</span></td>
          <td>${r.symbol_raw}</td>
          <td>${r.leverage_max_num ? `${r.leverage_max_num}x` : ''}</td>
          <td>${priceUsd(r.price_usd)}</td>
          <td>${usdShort(r.volume_24h_usd)}</td>
          <td>${usdShort(r.open_interest_usd)}</td>
          <td>${fmtRatio(r.vol_oi_ratio)}</td>
          <td>${fmtX(r.vol_vs_base_x, r.exchange === baselineSel.value)}</td>
          <td>${fmtX(r.oi_vs_base_x,  r.exchange === baselineSel.value)}</td>
        </tr>`;
      total++;
    }

    html += `<tr class="drawer-row" data-sym="${sym}" style="display:none;">
      <td colspan="10"><div class="drawer" id="drawer-${sym}"></div></td>
    </tr>`;
  }

  tbody.innerHTML = html;
  summary.textContent = `Showing ${total} rows across ${symbols.length} symbols.`;

  Array.from(document.querySelectorAll('.group-row')).forEach(tr => {
    tr.addEventListener('click', () => toggleDrawer(tr.dataset.sym));
  });
}

/* ===========================
   DRAWER + CHARTS
   =========================== */
async function toggleDrawer(symbol) {
  const row = document.querySelector(`.drawer-row[data-sym="${symbol}"]`);
  const host = document.getElementById(`drawer-${symbol}`);
  const isOpen = row.style.display !== 'none';
  if (isOpen) {
    // destroy charts when closing
    const ref = drawers.get(symbol);
    if (ref?.charts) {
      try { ref.charts.vol?.destroy?.(); } catch(_) {}
      try { ref.charts.oi?.destroy?.(); } catch(_) {}
    }
    drawers.delete(symbol);
    row.style.display = 'none';
    return;
  }
  row.style.display = '';
  // if reopened after render, always rebuild fresh
  host.innerHTML = renderDrawerSkeleton(symbol);
  await buildChartsFor(symbol, host);
}

function renderDrawerSkeleton(symbol) {
  return `
    <div class="chart-head">
      <div><strong>${symbol}</strong> • Charts</div>
      <div class="toggles">
        <label class="tog"><input type="checkbox" data-line="drift" checked> drift</label>
        <label class="tog"><input type="checkbox" data-line="dydx" checked> dYdX</label>
        <label class="tog"><input type="checkbox" data-line="hyperliquid" checked> hyperliquid</label>
        <span style="width:14px;"></span>
        <label class="tog">Rolling:
          <input type="number" min="1" step="1" value="1" style="width:70px" title="1 = daily (no rolling)"/>
        </label>
      </div>
    </div>
    <div class="charts">
      <div class="chart-card">
        <div class="chart-head">24h Volume (USD)</div>
        <canvas id="vol-${symbol}"></canvas>
      </div>
      <div class="chart-card">
        <div class="chart-head">Open Interest (USD)</div>
        <canvas id="oi-${symbol}"></canvas>
      </div>
    </div>
    <div class="note">Note: Volume uses <strong>rolling sum</strong>; Open Interest uses <strong>rolling mean</strong>. Set Rolling = 1 for daily (no rolling).</div>
    <div class="changes" id="changes-${symbol}"><h4>Recent changes</h4><ul></ul></div>
  `;
}

async function buildChartsFor(symbol, host) {
  const hist = await loadHistory(symbol);
  const rollingInput = host.querySelector('input[type="number"]');
  const toggles = host.querySelectorAll('input[type="checkbox"][data-line]');
  const volCtx = host.querySelector(`canvas#vol-${symbol}`).getContext('2d');
  const oiCtx  = host.querySelector(`canvas#oi-${symbol}`).getContext('2d');
  toggles.forEach(cb => { const ex = cb.dataset.line; cb.checked = !!exchangeOn[ex]; });

  // keep refs so we can destroy on close/re-render
  const charts = { vol:null, oi:null };
  drawers.set(symbol, { host, charts });

  const rebuild = () => {
    const win = Math.max(1, parseInt(rollingInput.value || '1', 10));
    const activeEx = Array.from(toggles).filter(cb => cb.checked).map(cb => cb.dataset.line);
    const { labels, volSeries, oiSeries } = seriesFor(symbol, hist, activeEx, win);
    const volData = { labels, datasets: activeEx.map(ex => ({ label: ex, data: volSeries[ex]||[], borderColor: COLORS[ex], backgroundColor: COLORS[ex], tension:0.2, fill:false, pointRadius:0 })) };
    const oiData  = { labels, datasets: activeEx.map(ex => ({ label: ex, data: oiSeries[ex]||[],  borderColor: COLORS[ex], backgroundColor: COLORS[ex], tension:0.2, fill:false, pointRadius:0 })) };
    const opts = { responsive:true, animation:false, interaction:{ mode:'index', intersect:false }, plugins:{ legend:{ labels:{ color:'#cbd5e1' } }, tooltip:{ callbacks:{ label:(c)=>`${c.dataset.label}: ${usdShort(c.parsed.y)}` } } }, scales:{ x:{ ticks:{ color:'#9ca3af', maxRotation:0, autoSkip:true } }, y:{ ticks:{ color:'#9ca3af', callback:(v)=>usdShort(v) }, grid:{ color:'#1f2937' } } } };

    try { charts.vol?.destroy?.(); } catch(_) {}
    try { charts.oi?.destroy?.(); } catch(_) {}
    charts.vol = new Chart(volCtx, { type:'line', data:volData, options:opts });
    charts.oi  = new Chart(oiCtx,  { type:'line', data:oiData,  options:opts });
  };

  rebuild();
  rollingInput.addEventListener('change', rebuild);
  toggles.forEach(cb => cb.addEventListener('change', rebuild));
  renderChanges(symbol, hist);
}

/* ===========================
   HISTORY LOADING (cache-busted)
   =========================== */
async function loadCSV(url) {
  const res = await fetch(`${url}?t=${Date.now()}`, { cache: 'no-store' });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const text = await res.text();
  const parsed = Papa.parse(text, { header:true, skipEmptyLines:true });
  return parsed.data || [];
}
async function loadHistory(symbol) {
  if (historyCache.has(symbol)) return historyCache.get(symbol);
  
  // Use preloaded historical data with symbol alias resolution
  const canonicalSymbol = resolveSymbol(symbol);
  const rows = historicalData.filter(r => {
    const rowSymbol = resolveSymbol(r.symbol_raw);
    return rowSymbol === canonicalSymbol;
  });
  
  const byDateEx = new Map(), dates = new Set();
  for (const r of rows) {
    const d = r.daily_snapshot || ''; if (!d) continue;
    dates.add(d);
    byDateEx.set(`${d}|${r.exchange}`, { vol: r.volume_num || 0, oi: r.oi_num || 0, mt: r.market_type || '', lev: r.leverage_max_num || null });
  }
  const dateArr = Array.from(dates).sort();
  const result = {
    dates: dateArr,
    byEx: { drift: dateArr.map(d => byDateEx.get(`${d}|drift`)?.vol ?? 0),
            dydx:  dateArr.map(d => byDateEx.get(`${d}|dydx`)?.vol ?? 0),
            hyperliquid: dateArr.map(d => byDateEx.get(`${d}|hyperliquid`)?.vol ?? 0) },
    byExOI: { drift: dateArr.map(d => byDateEx.get(`${d}|drift`)?.oi ?? 0),
              dydx:  dateArr.map(d => byDateEx.get(`${d}|dydx`)?.oi ?? 0),
              hyperliquid: dateArr.map(d => byDateEx.get(`${d}|hyperliquid`)?.oi ?? 0) },
    meta: { changes: detectChanges(dateArr, byDateEx) }
  };
  historyCache.set(symbol, result);
  return result;
}
function rollingSum(arr, win){ if (win<=1) return arr.slice(); const out=Array(arr.length).fill(0); let s=0; for(let i=0;i<arr.length;i++){ s+=arr[i]||0; if(i>=win)s-=arr[i-win]||0; out[i]=(i>=win-1)?s:null;} return out; }
function rollingMean(arr, win){ if (win<=1) return arr.slice(); const sum=rollingSum(arr,win); return sum.map((v)=>v===null?null:(v/win)); }
function seriesFor(symbol, hist, activeEx, win) {
  const labels = hist.dates; const volSeries = {}; const oiSeries = {};
  for (const ex of activeEx) { const vol = hist.byEx[ex]||[]; const oi = hist.byExOI[ex]||[]; volSeries[ex]=rollingSum(vol,win); oiSeries[ex]=rollingMean(oi,win); }
  return { labels, volSeries, oiSeries };
}

/* ===========================
   CHANGE TRACKER
   =========================== */
function detectChanges(dateArr, byDateEx) {
  const exes = ['dydx','drift','hyperliquid']; const changes=[];
  for (const ex of exes) {
    let prev=null;
    for (const d of dateArr) {
      const cur = byDateEx.get(`${d}|${ex}`) || null; if (!cur) continue;
      if (prev) {
        if ((prev.mt||'') !== (cur.mt||'')) changes.push({ date:d, ex, field:'market_type', from: prev.mt||'—', to: cur.mt||'—' });
        const pl = prev.lev ?? '—', cl = cur.lev ?? '—'; if (pl !== cl) changes.push({ date:d, ex, field:'leverage_max', from: pl, to: cl });
      }
      prev = cur;
    }
  }
  return changes.sort((a,b)=> a.date < b.date ? 1 : -1);
}
function renderChanges(symbol, hist) {
  const box = document.getElementById(`changes-${symbol}`); const ul = box.querySelector('ul');
  if (!hist.meta.changes.length) { ul.innerHTML = `<li>No changes detected in recent history.</li>`; return; }
  ul.innerHTML = hist.meta.changes.slice(0,12).map(c=>`<li>${c.date} • <strong>${c.ex}</strong> • ${c.field}: <em>${c.from}</em> → <em>${c.to}</em></li>`).join('');
}

/* ===========================
   FILTERS & SORT
   =========================== */
function applyFilters() {
  const q = String(symFilterEl.value || '').trim().toUpperCase();
  const t = String(typeFilterEl.value || '').toUpperCase();
  rowsFiltered = rowsRaw.filter(r => {
    if (!exchangeOn[r.exchange]) return false;
    
    // Symbols are already resolved during data loading
    if (q && !String(r.symbol_raw || '').toUpperCase().includes(q)) return false;
    
    if (t && String(r.market_type || '').toUpperCase() !== t) return false;
    return true;
  });
  renderTable(rowsFiltered);
}
function setSort(newKey) {
  if (sortKey === newKey) sortDir = (sortDir === 'asc') ? 'desc' : 'asc';
  else { sortKey = newKey; sortDir = 'desc'; }
  headerCells.forEach(th => {
    th.classList.toggle('active', th.dataset.key === sortKey);
    const arrow = th.querySelector('.arrow');
    if (arrow) arrow.textContent = (th.dataset.key === sortKey) ? (sortDir === 'asc' ? '↑' : '↓') : '↕';
  });
  renderTable(rowsFiltered);
}

/* ===========================
   LOAD ALL DATA FROM API
   =========================== */
async function loadAllData() {
  if (isLoading) return;
  isLoading = true;
  
  showProgressBar('Loading market data...');
  
  try {
    // Load all data in parallel
    const [latestResponse, historicalResponse, aliasesResponse] = await Promise.all([
      apiClient.getLatestData(),
      apiClient.getAllDailyData(),
      apiClient.getSymbolAliases()
    ]);
    
    // Process symbol aliases FIRST
    symbolAliases.clear();
    (aliasesResponse.data || []).forEach(alias => {
      if (alias.symbol_raw && alias.symbol_canonical) {
        symbolAliases.set(alias.symbol_raw, alias.symbol_canonical);
      }
    });
    
    // Process latest data with symbol alias resolution
    rowsRaw = (latestResponse.data || []).map(row => {
      const processed = ensureColumns(row);
      // Apply symbol alias resolution for grouping
      if (processed.symbol_raw) {
        processed.symbol_raw = resolveSymbol(processed.symbol_raw);
      }
      return processed;
    });
    
    // Process historical data with symbol alias resolution
    historicalData = (historicalResponse.data || []).map(row => {
      const processed = ensureColumns(row);
      // Apply symbol alias resolution for grouping
      if (processed.symbol_raw) {
        processed.symbol_raw = resolveSymbol(processed.symbol_raw);
      }
      return processed;
    });
    
    // Update UI
    const now = new Date();
    const dateOnly = now.toISOString().split('T')[0]; // Get just the date part
    const hour = now.getUTCHours();
    const ampm = hour >= 12 ? 'PM' : 'AM';
    const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
    
    // Update only the text content, preserve the GitHub icon
    const textNode = titleEl.childNodes[0];
    if (textNode && textNode.nodeType === Node.TEXT_NODE) {
      textNode.textContent = 'Market Comparer';
    } else {
      // Fallback: if structure is different, rebuild with icon
      titleEl.innerHTML = 'Market Comparer<a href="https://github.com/Pocket-Protector/Market-Comparer" target="_blank" class="github-link" title="View on GitHub"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg></a>';
    }
    lastUpdatedEl.textContent = `Last updated (UTC): ${dateOnly} - ${displayHour}${ampm}`;
    
    lastLoadTs = Date.now();
    applyFilters();
    
    hideProgressBar();
    
  } catch (error) {
    console.error('Failed to load data:', error);
    showError(`Failed to load data: ${error.message}`);
    hideProgressBar();
    
    // Show error in table
    tbody.innerHTML = `<tr><td colspan="10" class="empty">Failed to load data from API: ${error.message}</td></tr>`;
    lastUpdatedEl.textContent = 'Failed to load data';
  } finally {
    isLoading = false;
  }
}

/* ===========================
   EVENTS
   =========================== */
document.getElementById('exchangeChips').addEventListener('click', (e) => {
  const el = e.target.closest('.chip'); if (!el) return;
  const ex = el.dataset.ex;
  el.classList.toggle('on');
  exchangeOn[ex] = el.classList.contains('on');
  applyFilters(); // will dispose charts + rebuild table safely
});

// Removed refresh button event listener

symFilterEl.addEventListener('input', applyFilters);
typeFilterEl.addEventListener('change', applyFilters);
presenceEl.addEventListener('change', applyFilters);
baselineSel.addEventListener('change', () => renderTable(rowsFiltered));
headerCells.forEach(th => th.addEventListener('click', () => setSort(th.dataset.key)));

/* Auto-refresh every hour and when tab regains focus */
let updateProgressInterval;

function startUpdateProgress() {
  const updateProgressEl = document.getElementById('updateProgress');
  const progressFillEl = document.getElementById('progressFill');
  const progressTextEl = document.getElementById('progressText');
  
  if (!updateProgressEl || !progressFillEl || !progressTextEl) return;
  
  updateProgressEl.style.display = 'flex';
  
  function updateProgress() {
    const now = new Date();
    const currentMinute = now.getUTCMinutes();
    
    // Calculate next update time (5th minute of next hour)
    let nextUpdate = new Date(now);
    if (currentMinute < 5) {
      // If we're before 5 minutes, next update is at 5 minutes of current hour
      nextUpdate.setUTCMinutes(5, 0, 0);
    } else {
      // If we're after 5 minutes, next update is at 5 minutes of next hour
      nextUpdate.setUTCHours(nextUpdate.getUTCHours() + 1, 5, 0, 0);
    }
    
    const timeUntilUpdate = nextUpdate.getTime() - now.getTime();
    const minutesUntilUpdate = Math.ceil(timeUntilUpdate / (1000 * 60));
    
    // Calculate progress based on time since last 5-minute mark
    const lastUpdate = new Date(now);
    if (currentMinute >= 5) {
      lastUpdate.setUTCMinutes(5, 0, 0);
    } else {
      lastUpdate.setUTCHours(lastUpdate.getUTCHours() - 1, 5, 0, 0);
    }
    
    const timeSinceLastUpdate = now.getTime() - lastUpdate.getTime();
    const totalCycleTime = 60 * 60 * 1000; // 60 minutes in milliseconds
    const progressPercent = Math.max(0, Math.min(100, (timeSinceLastUpdate / totalCycleTime) * 100));
    
    progressFillEl.style.width = `${progressPercent}%`;
    
    if (minutesUntilUpdate > 0) {
      progressTextEl.textContent = `Updates in ${minutesUntilUpdate}m`;
    } else {
      progressTextEl.textContent = 'Updating...';
      // Trigger refresh when it's time
      loadAllData().catch(console.error);
    }
  }
  
  updateProgress(); // Initial call
  updateProgressInterval = setInterval(updateProgress, 60000); // Update every minute
}

// Auto-refresh when tab regains focus (if older than 5 min)
document.addEventListener('visibilitychange', async () => {
  if (document.visibilityState === 'visible') {
    const STALE_MS = 5 * 60 * 1000;
    if (Date.now() - lastLoadTs > STALE_MS) {
      try { await loadAllData(); } catch (_) {}
    }
  }
});

// Start progress tracking after initial load
setTimeout(startUpdateProgress, 1000);

/* BOOT */
loadAllData().catch(err => {
  tbody.innerHTML = `<tr><td colspan="10" class="empty">Failed to load data from API (${String(err)}). Check API configuration.</td></tr>`;
  lastUpdatedEl.textContent = 'Failed to load data';
});
</script>
</body>
</html>
